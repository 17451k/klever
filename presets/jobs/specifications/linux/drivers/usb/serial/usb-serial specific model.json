{
  "Linux 3.14 (base)": {
    "manual event models": [
      {
        "fragments": [
          "drivers/usb/serial/usbserial.ko"
        ],
        "model": {
          "functions models": {
            "functions models/driver_register": {
              "actions": {
                "assign": {
                  "comment": "Get callbacks to register bus type.",
                  "statements": [
                    "%driver% = $ARG1;"
                  ]
                },
                "fail": {
                  "comment": "Registration failed.",
                  "statements": [
                    "return ldv_undef_int_negative();"
                  ]
                },
                "register": {
                  "comment": "Register {} callbacks.",
                  "parameters": [
                    "%driver%"
                  ],
                  "peers": [
                    "bus/bus_scenario/usb_serial_bus_type"
                  ]
                },
                "success": {
                  "comment": "Registration of bus_type callbacks has been finished successfully.",
                  "statements": [
                    "return 0;"
                  ]
                }
              },
              "category": "functions models",
              "comment": "Register bus_type callbacks.",
              "declarations": {},
              "identifier": "functions models/driver_register",
              "labels": {
                "driver": {
                  "declaration": "struct driver *driver"
                }
              },
              "process": "<assign>.[register].<success> | <fail>"
            },
            "functions models/driver_unregister": {
              "actions": {
                "assign": {
                  "comment": "Get bus type callbacks.",
                  "statements": [
                    "%driver% = $ARG1;"
                  ]
                },
                "deregister": {
                  "broadcast": true,
                  "comment": "Deregister bus type callbacks.",
                  "parameters": [
                    "%driver%"
                  ],
                  "peers": [
                    "bus/bus_scenario/usb_serial_bus_type"
                  ]
                }
              },
              "category": "functions models",
              "comment": "Deregister bus type callbacks.",
              "identifier": "functions models/driver_unregister",
              "labels": {
                "driver": {
                  "declaration": "struct device_driver *drv"
                }
              },
              "process": "<assign>.[@deregister]"
            }
          },
          "environment processes": {
            "bus/bus_scenario/usb_serial_bus_type": {
              "actions": {
                "match": {
                  "comment": "Call match callback",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_wrapper_usb_serial_device_match(%device%, %device_driver%);\", \"type\": \"CALLBACK\", \"comment\": \"match\"} */",
                    "ldv_wrapper_usb_serial_device_match(%device%, %device_driver%);"
                  ]
                },
                "show": {
                  "comment": "Show callback",
                  "entry point": true,
                  "statements": [
                    "$ALLOC(%buf%);",
                    "/* LDV {\"call\": \"ldv_wrapper_new_id_show(%device_driver%, %buf%);\", \"type\": \"CALLBACK\", \"comment\": \"show\"} */",
                    "ldv_wrapper_new_id_show(%device_driver%, %buf%);",
                    "$FREE(%buf%);"
                  ]
                },
                "store": {
                  "comment": "Store callback",
                  "entry point": true,
                  "statements": [
                    "$ALLOC(%buf%);",
                    "%count% = ldv_undef_int();",
                    "/* LDV {\"call\": \"ldv_wrapper_new_id_store(%device_driver%, %buf%, %count%);\", \"type\": \"CALLBACK\", \"comment\": \"show\"} */",
                    "ldv_wrapper_new_id_store(%device_driver%, %buf%, %count%);",
                    "$FREE(%buf%);"
                  ]
                },
                "alloc": {
                  "comment": "Allocate memory.",
                  "statements": [
                    "%device% = $ALLOC(%device%);"
                  ]
                },
                "skip": {
                  "comment": "Do nothing",
                  "statements": []
                },
                "deregister": {
                  "comment": "Finish {} callbacks invocations scenario.",
                  "condition": [],
                  "parameters": [
                    "%device_driver%"
                  ],
                  "peers": [
                    "functions models/driver_unregister"
                  ]
                },
                "failed_probe": {
                  "comment": "Probing failed.",
                  "condition": [
                    "%probe_retval% != 0"
                  ]
                },
                "manage_interface": {
                  "comment": "Manage particular interface on a device.",
                  "process": "<probe>.(<probe_success>.(<match> | <show> | <store> | <skip>).<release> | <failed_probe>).{manage_interface} | (deregister)"
                },
                "probe": {
                  "comment": "Probe device.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"%probe_retval% = ldv_wrapper_usb_serial_device_probe(%device%);\", \"type\": \"CALLBACK\", \"comment\": \"probe\"} */",
                    "%probe_retval% = ldv_wrapper_usb_serial_device_probe(%device%);",
                    "/* Callback post-call */",
                    "%probe_retval% = ldv_post_probe(%probe_retval%);"
                  ]
                },
                "probe_success": {
                  "comment": "Check that interface has been probed successfully.",
                  "condition": [
                    "%probe_retval% == 0"
                  ]
                },
                "register": {
                  "comment": "Begin USB callbacks invocation scenario.",
                  "condition": [],
                  "parameters": [
                    "%device_driver%"
                  ],
                  "peers": [
                    "functions models/driver_register"
                  ],
                  "replicative": true
                },
                "release": {
                  "comment": "Remove device.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_wrapper_usb_serial_device_remove(%device%);\", \"type\": \"CALLBACK\", \"comment\": \"release\"} */",
                    "ldv_wrapper_usb_serial_device_remove(%device%);"
                  ]
                }
              },
              "category": "bys_type",
              "comment": "Invoke usb serial bus type callbacks. (Relevant to 'usb_serial_bus_type')",
              "declarations": {
                "environment model": {
                  "& usb_serial_device_match": "extern int ldv_wrapper_usb_serial_device_match(struct device *dev, struct device_driver *drv);\n",
                  "& usb_serial_device_probe": "extern int ldv_wrapper_usb_serial_device_probe(struct device *dev);\n",
                  "& usb_serial_device_remove": "extern int ldv_wrapper_usb_serial_device_remove(struct device *dev);\n",
                  "& new_id_store": "extern ssize_t ldv_wrapper_new_id_store(struct device_driver *driver, const char *buf, size_t count);\n",
                  "& new_id_show": "extern ssize_t ldv_wrapper_new_id_show(struct device_driver *driver, char *buf);\n"
                }
              },
              "definitions": {
                "drivers/usb/serial/bus.c": {
                  "usb_serial_device_match": [
                    "/* AUX_FUNC ldv_wrapper_usb_serial_device_match */\n",
                    "int ldv_wrapper_usb_serial_device_match(struct device *dev, struct device_driver *drv) {\n",
                    "\t usb_serial_device_match(dev, drv);\n",
                    "}\n",
                    "\n"
                  ],
                  "usb_serial_device_probe": [
                    "/* AUX_FUNC ldv_wrapper_usb_serial_device_probe */\n",
                    "int ldv_wrapper_usb_serial_device_probe(struct device *dev) {\n",
                    "\treturn usb_serial_device_probe(dev);\n",
                    "}\n",
                    "\n"
                  ],
                  "usb_serial_device_remove": [
                    "/* AUX_FUNC ldv_wrapper_usb_serial_device_remove */\n",
                    "int ldv_wrapper_usb_serial_device_remove(struct device *dev) {\n",
                    "\treturn usb_serial_device_remove(dev);\n",
                    "}\n",
                    "\n"
                  ],
                  "new_id_store": [
                    "/* AUX_FUNC ldv_wrapper_new_id_store */\n",
                    "ssize_t ldv_wrapper_new_id_store(struct device_driver *driver, const char *buf, size_t count) {\n",
                    "\treturn new_id_store(driver, buf, count);\n",
                    "}\n",
                    "\n"
                  ],
                  "new_id_show": [
                    "/* AUX_FUNC ldv_wrapper_new_id_show */\n",
                    "ssize_t ldv_wrapper_new_id_show(struct device_driver *driver, char *buf) {\n",
                    "\treturn new_id_show(driver, buf);\n",
                    "}\n",
                    "\n"
                  ]
                }
              },
              "headers": [
                "linux/device.h"
              ],
              "identifier": "bus/bus_scenario/usb_serial_bus_type",
              "labels": {
                "probe_retval": {
                  "declaration": "int probe_retval",
                  "value": "ldv_undef_int()"
                },
                "device": {
                  "declaration": "struct device *dev"
                },
                "device_driver": {
                  "declaration": "struct device_driver *drv"
                },
                "buf": {
                  "declaration": "char *buf"
                },
                "count": {
                  "declaration": "size_t count"
                }
              },
              "process": "(!register).<alloc>.{manage_interface}"
            },
            "usb_serial/tty_layer/usb_serial_generic_device": {
              "actions": {
                "deregister_tty_layer": {
                  "comment": "End up with USB serial tty layer callbacks invocation scenario.",
                  "condition": [
                    "%driver% == $ARG1",
                    "$ARG1 == ldv_emg_alias_debug_device_2",
                    "$ARG1 == &usb_serial_generic_device"
                  ],
                  "parameters": [
                    "%driver%"
                  ],
                  "peers": [
                    "usb_serial/usb_serial_scenario/usb_serial_generic_device"
                  ]
                },
                "irq_write_4": {
                  "comment": "Write a block of characters to the tty device in atomic context. Invoke callback irq_write from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "if (%driver%->write) {",
                    "\t/* Callback pre-call */",
                    "\tldv_switch_to_interrupt_context();",
                    "\t/* LDV {\"call\": \"%driver%->write(%resource_1%, %ldv_param_1_2%, %ldv_param_2_3%, %ldv_param_3_4%);\", \"type\": \"CALLBACK\", \"comment\": \"irq_write\"} */",
                    "\t%driver%->write(%resource_1%, %ldv_param_1_2%, %ldv_param_2_3%, %ldv_param_3_4%);",
                    "\t/* Callback post-call */",
                    "\tldv_switch_to_process_context();",
                    "}"
                  ]
                },
                "post_call_11": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_8%);"
                  ]
                },
                "post_call_14": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_9%);"
                  ]
                },
                "post_call_17": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_0_10%);",
                    "$FREE(%ldv_param_2_11%);"
                  ]
                },
                "post_call_21": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_12%);"
                  ]
                },
                "post_call_25": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_0_13%);"
                  ]
                },
                "post_call_28": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_0_14%);"
                  ]
                },
                "post_call_3": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_3_4%);",
                    "$FREE(%ldv_param_2_3%);",
                    "$FREE(%ldv_param_1_2%);"
                  ]
                },
                "post_call_6": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_2_6%);",
                    "$FREE(%ldv_param_1_5%);",
                    "$FREE(%ldv_param_3_7%);"
                  ]
                },
                "pre_call_10": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_8% = $UALLOC(%ldv_param_1_8%);"
                  ]
                },
                "pre_call_13": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_9% = $UALLOC(%ldv_param_1_9%);"
                  ]
                },
                "pre_call_16": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_0_10% = $UALLOC(%ldv_param_0_10%);",
                    "%ldv_param_2_11% = $UALLOC(%ldv_param_2_11%);"
                  ]
                },
                "pre_call_2": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_3_4% = $UALLOC(%ldv_param_3_4%);",
                    "%ldv_param_2_3% = $UALLOC(%ldv_param_2_3%);",
                    "%ldv_param_1_2% = $UALLOC(%ldv_param_1_2%);"
                  ]
                },
                "pre_call_20": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_12% = $UALLOC(%ldv_param_1_12%);"
                  ]
                },
                "pre_call_24": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_0_13% = $UALLOC(%ldv_param_0_13%);"
                  ]
                },
                "pre_call_27": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_0_14% = $UALLOC(%ldv_param_0_14%);"
                  ]
                },
                "pre_call_5": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_2_6% = $UALLOC(%ldv_param_2_6%);",
                    "%ldv_param_1_5% = $UALLOC(%ldv_param_1_5%);",
                    "%ldv_param_3_7% = $UALLOC(%ldv_param_3_7%);"
                  ]
                },
                "register_tty_layer": {
                  "comment": "Begin USB serial tty layer callbacks invocation scenario.",
                  "condition": [
                    "$ARG1 == &usb_serial_generic_device"
                  ],
                  "parameters": [
                    "%driver%",
                    "%port%",
                    "%resource_1%"
                  ],
                  "peers": [
                    "usb_serial/usb_serial_scenario/usb_serial_generic_device"
                  ],
                  "replicative": true
                },
                "rest_line_attached_callbacks_12": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_tiocmiwait(%resource_1%, %ldv_param_1_8%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_tiocmiwait(%resource_1%, %ldv_param_1_8%);"
                  ]
                },
                "rest_line_attached_callbacks_15": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_get_icount(%resource_1%, %ldv_param_1_9%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_get_icount(%resource_1%, %ldv_param_1_9%);"
                  ]
                },
                "rest_line_attached_callbacks_18": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_prepare_write_buffer(%ldv_param_0_10%, %resource_0%, %ldv_param_2_11%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_prepare_write_buffer(%ldv_param_0_10%, %resource_0%, %ldv_param_2_11%);"
                  ]
                },
                "rest_line_attached_callbacks_19": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_chars_in_buffer(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_chars_in_buffer(%resource_1%);"
                  ]
                },
                "rest_line_attached_callbacks_22": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_wait_until_sent(%resource_1%, %ldv_param_1_12%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_wait_until_sent(%resource_1%, %ldv_param_1_12%);"
                  ]
                },
                "rest_line_attached_callbacks_23": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_write_room(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_write_room(%resource_1%);"
                  ]
                },
                "rest_line_attached_callbacks_26": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_read_bulk_callback(%ldv_param_0_13%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_read_bulk_callback(%ldv_param_0_13%);"
                  ]
                },
                "rest_line_attached_callbacks_29": {
                  "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_write_bulk_callback(%ldv_param_0_14%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                    "usb_serial_generic_write_bulk_callback(%ldv_param_0_14%);"
                  ]
                },
                "throttle_8": {
                  "comment": "Notify the tty driver that input buffers for the line discipline are close to full. Invoke callback throttle from usb_serial_driver.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_throttle(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"throttle\"} */",
                    "usb_serial_generic_throttle(%resource_1%);"
                  ]
                },
                "tty_layer": {
                  "comment": "Call the rest callbacks from tty layer.",
                  "process": "(<throttle_8>.<unthrottle_9> | <carrier_raised> | <dtr> | <pre_call_2>.<irq_write_4>.<post_call_3> | <pre_call_5>.<write_7>.<post_call_6> | <pre_call_10>.(((((((<rest_line_attached_callbacks_12> | <pre_call_27>.<rest_line_attached_callbacks_29>.<post_call_28>) | <pre_call_24>.<rest_line_attached_callbacks_26>.<post_call_25>) | <rest_line_attached_callbacks_23>) | <pre_call_20>.<rest_line_attached_callbacks_22>.<post_call_21>) | <rest_line_attached_callbacks_19>) | <pre_call_16>.<rest_line_attached_callbacks_18>.<post_call_17>) | <pre_call_13>.<rest_line_attached_callbacks_15>.<post_call_14>).<post_call_11>).{tty_layer} | (deregister_tty_layer)"
                },
                "dtr": {
                  "comment": ".",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_wrapper_serial_port_dtr_rts(& %port%->port, ldv_undef_int());\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                    "ldv_wrapper_serial_port_dtr_rts(& %port%->port, ldv_undef_int());"
                  ]
                },
                "carrier_raised": {
                  "comment": "Call serial_port_carrier_raised.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_wrapper_serial_port_carrier_raised(& %port%->port);\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                    "ldv_wrapper_serial_port_carrier_raised(& %port%->port);"
                  ]
                },
                "unthrottle_9": {
                  "comment": "Notify the tty drivers that it should signals that characters can now be sent. Invoke callback unthrottle from usb_serial_driver.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"usb_serial_generic_unthrottle(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                    "usb_serial_generic_unthrottle(%resource_1%);"
                  ]
                },
                "write_7": {
                  "comment": "Write a block of characters to the tty device in atomic context. Invoke callback write from USB_SERIAL.",
                  "entry point": true,
                  "statements": [
                    "if (%driver%->write) {",
                    "\t/* LDV {\"call\": \"%driver%->write(%resource_1%, %ldv_param_1_5%, %ldv_param_2_6%, %ldv_param_3_7%);\", \"type\": \"CALLBACK\", \"comment\": \"write\"} */",
                    "\t%driver%->write(%resource_1%, %ldv_param_1_5%, %ldv_param_2_6%, %ldv_param_3_7%);",
                    "}"
                  ]
                }
              },
              "category": "usb_serial",
              "comment": "Invoke USB serial tty layer callbacks. (Relevant to 'usb_serial_generic_device')",
              "declarations": {
                "drivers/usb/serial/usb_debug.c": {
                  "debug_device": "struct usb_serial_driver *ldv_emg_alias_debug_device_2 = & debug_device;\n"
                },
                "environment model": {
                  "& usb_serial_generic_throttle": "extern void usb_serial_generic_throttle(struct tty_struct *tty);\n",
                  "& usb_serial_generic_unthrottle": "extern void usb_serial_generic_unthrottle(struct tty_struct *tty);\n",
                  "&usb_serial_generic_chars_in_buffer": "extern int usb_serial_generic_chars_in_buffer(struct tty_struct *tty);\n",
                  "&usb_serial_generic_get_icount": "extern int usb_serial_generic_get_icount(struct tty_struct *tty, struct serial_icounter_struct *icount);\n",
                  "&usb_serial_generic_prepare_write_buffer": "extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port, void *dest, size_t size);\n",
                  "&usb_serial_generic_read_bulk_callback": "extern void usb_serial_generic_read_bulk_callback(struct urb *urb);\n",
                  "&usb_serial_generic_tiocmiwait": "extern int usb_serial_generic_tiocmiwait(struct tty_struct *tty, long unsigned int arg);\n",
                  "&usb_serial_generic_wait_until_sent": "extern void usb_serial_generic_wait_until_sent(struct tty_struct *tty, long int timeout);\n",
                  "&usb_serial_generic_write_bulk_callback": "extern void usb_serial_generic_write_bulk_callback(struct urb *urb);\n",
                  "&usb_serial_generic_write_room": "extern int usb_serial_generic_write_room(struct tty_struct *tty);\n",
                  "debug_device": "extern struct usb_serial_driver *ldv_emg_alias_debug_device_2;\n",
                  "usb_debug_break_ctl": "extern void ldv_emg_wrapper_usb_debug_break_ctl_3(struct tty_struct *, int);\n",
                  "usb_debug_process_read_urb": "extern void ldv_emg_wrapper_usb_debug_process_read_urb_4(struct urb *);\n",
                  "usb_serial_generic_device": "extern struct usb_serial_driver usb_serial_generic_device;\n",
                  "& serial_port_carrier_raised": "extern int ldv_wrapper_serial_port_carrier_raised(struct tty_port *port);\n",
                  "& serial_port_dtr_rts": "extern void ldv_wrapper_serial_port_dtr_rts(struct tty_port *port, int on);\n"
                }
              },
              "definitions": {
                "drivers/usb/serial/usb_debug.c": {
                  "usb_debug_break_ctl": [
                    "/* AUX_FUNC ldv_emg_wrapper_usb_debug_break_ctl_3 */\n",
                    "void ldv_emg_wrapper_usb_debug_break_ctl_3(struct tty_struct *arg0, int arg1) {\n",
                    "\t usb_debug_break_ctl(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "usb_debug_process_read_urb": [
                    "/* AUX_FUNC ldv_emg_wrapper_usb_debug_process_read_urb_4 */\n",
                    "void ldv_emg_wrapper_usb_debug_process_read_urb_4(struct urb *arg0) {\n",
                    "\t usb_debug_process_read_urb(arg0);\n",
                    "}\n",
                    "\n"
                  ]
                },
                "drivers/usb/serial/usb-serial.c": {
                  "serial_port_carrier_raised": [
                    "/* AUX_FUNC ldv_wrapper_serial_port_carrier_raised */\n",
                    "int ldv_wrapper_serial_port_carrier_raised(struct tty_port *port) {\n",
                    "\t serial_port_carrier_raised(port);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_port_dtr_rts": [
                    "/* AUX_FUNC ldv_wrapper_serial_port_dtr_rts */\n",
                    "void ldv_wrapper_serial_port_dtr_rts(struct tty_port *port, int on) {\n",
                    "\t serial_port_dtr_rts(port, on);\n",
                    "}\n",
                    "\n"
                  ],
                  "device_del": [
                    "/* AUX_FUNC device_del */\n",
                    "void device_del(struct device *dev) {\n",
                    "\t usb_serial_port_release(dev);\n",
                    "}\n",
                    "\n"
                  ]
                }
              },
              "headers": [
                "linux/tty.h"
              ],
              "identifier": "usb_serial/tty_layer/usb_serial_generic_device",
              "labels": {
                "driver": {
                  "declaration": "struct usb_serial_driver *driver",
                  "value": "&usb_serial_generic_device"
                },
                "ldv_param_0_10": {
                  "declaration": "struct usb_serial_port *ldv_param_0_10"
                },
                "ldv_param_0_13": {
                  "declaration": "struct urb *ldv_param_0_13"
                },
                "ldv_param_0_14": {
                  "declaration": "struct urb *ldv_param_0_14"
                },
                "ldv_param_1_12": {
                  "declaration": "long int ldv_param_1_12"
                },
                "ldv_param_1_2": {
                  "declaration": "struct usb_serial_port *ldv_param_1_2"
                },
                "ldv_param_1_5": {
                  "declaration": "struct usb_serial_port *ldv_param_1_5"
                },
                "ldv_param_1_8": {
                  "declaration": "long unsigned int ldv_param_1_8"
                },
                "ldv_param_1_9": {
                  "declaration": "struct serial_icounter_struct *ldv_param_1_9"
                },
                "ldv_param_2_11": {
                  "declaration": "long unsigned int ldv_param_2_11"
                },
                "ldv_param_2_3": {
                  "declaration": "unsigned char *ldv_param_2_3"
                },
                "ldv_param_2_6": {
                  "declaration": "unsigned char *ldv_param_2_6"
                },
                "ldv_param_3_4": {
                  "declaration": "int ldv_param_3_4"
                },
                "ldv_param_3_7": {
                  "declaration": "int ldv_param_3_7"
                },
                "port": {
                  "declaration": "struct usb_serial_port *port"
                },
                "resource_0": {
                  "declaration": "struct usb_serial *resource_0"
                },
                "resource_1": {
                  "declaration": "struct tty_struct *resource_1"
                }
              },
              "process": "(!register_tty_layer).{tty_layer}"
            },
            "tty/tty_scenario/serial_ops": {
              "actions": {
                "call": {
                  "comment": "Call rest tty callbacks.",
                  "process": "((((((((((((<callback_2> | <seq_ops> | <pre_call_27>.<callback_29>.<post_call_28>) | <pre_call_24>.<callback_26>.<post_call_25>) | <pre_call_21>.<callback_23>.<post_call_22>) | <pre_call_18>.<callback_20>.<post_call_19>) | <pre_call_15>.<callback_17>.<post_call_16>) | <callback_14>) | <pre_call_11>.<callback_13>.<post_call_12>) | <callback_10>) | <pre_call_7>.<callback_9>.<post_call_8>) | <callback_6>) | <pre_call_3>.<callback_5>.<post_call_4>) | <pre_call_41>.<set_termios_43>.<post_call_42> | <throttle_47>.<unthrottle_48> | <start_49>.<stop_50> | <pre_call_44>.<set_termiox_46>.<post_call_45>).{call} | <pre_call_36>.<close_38>.<post_call_37>.<shutdown_39>.<remove_34>.<cleanup_40>.{main}"
                },
                "callback_10": {
                  "comment": "Invoke callback write_room from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_write_room_6(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_write_room_6(%tty_struct%);"
                  ]
                },
                "callback_13": {
                  "comment": "Invoke callback activate from tty_port_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_port_activate_7(%ldv_param_0_4%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_port_activate_7(%ldv_param_0_4%, %tty_struct%);"
                  ]
                },
                "callback_14": {
                  "comment": "Invoke callback hangup from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_hangup_8(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_hangup_8(%tty_struct%);"
                  ]
                },
                "callback_17": {
                  "comment": "Invoke callback write from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_write_9(%tty_struct%, %ldv_param_1_5%, %ldv_param_2_6%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_write_9(%tty_struct%, %ldv_param_1_5%, %ldv_param_2_6%);"
                  ]
                },
                "callback_2": {
                  "comment": "Invoke callback tiocmget from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_tiocmget_2(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_tiocmget_2(%tty_struct%);"
                  ]
                },
                "callback_20": {
                  "comment": "Invoke callback tiocmset from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_tiocmset_10(%tty_struct%, %ldv_param_1_7%, %ldv_param_2_8%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_tiocmset_10(%tty_struct%, %ldv_param_1_7%, %ldv_param_2_8%);"
                  ]
                },
                "callback_23": {
                  "comment": "Invoke callback wait_until_sent from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_wait_until_sent_11(%tty_struct%, %ldv_param_1_9%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_wait_until_sent_11(%tty_struct%, %ldv_param_1_9%);"
                  ]
                },
                "callback_26": {
                  "comment": "Invoke callback shutdown from tty_port_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_port_shutdown_12(%ldv_param_0_10%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_port_shutdown_12(%ldv_param_0_10%);"
                  ]
                },
                "callback_29": {
                  "comment": "Invoke callback ioctl from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_ioctl_13(%tty_struct%, %ldv_param_1_11%, %ldv_param_2_12%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_ioctl_13(%tty_struct%, %ldv_param_1_11%, %ldv_param_2_12%);"
                  ]
                },
                "callback_5": {
                  "comment": "Invoke callback break_ctl from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_break_3(%tty_struct%, %ldv_param_1_2%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_break_3(%tty_struct%, %ldv_param_1_2%);"
                  ]
                },
                "callback_6": {
                  "comment": "Invoke callback chars_in_buffer from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_chars_in_buffer_4(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_chars_in_buffer_4(%tty_struct%);"
                  ]
                },
                "callback_9": {
                  "comment": "Invoke callback get_icount from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_get_icount_5(%tty_struct%, %ldv_param_1_3%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                    "ldv_emg_wrapper_serial_get_icount_5(%tty_struct%, %ldv_param_1_3%);"
                  ]
                },
                "cleanup_40": {
                  "comment": "Free resources after a tty device has been closed for the last time. Invoke callback cleanup from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_cleanup_17(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"cleanup\"} */",
                    "ldv_emg_wrapper_serial_cleanup_17(%tty_struct%);"
                  ]
                },
                "close_38": {
                  "comment": "Close a tty device. Invoke callback close from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_close_16(%tty_struct%, %ldv_param_1_15%);\", \"type\": \"CALLBACK\", \"comment\": \"close\"} */",
                    "ldv_emg_wrapper_serial_close_16(%tty_struct%, %ldv_param_1_15%);"
                  ]
                },
                "deregister": {
                  "comment": "Finish {} callbacks invocations scenario.",
                  "condition": [
                    "%tty_driver% == $ARG1",
                    "$ARG2 == ldv_emg_alias_serial_ops_2"
                  ],
                  "parameters": [
                    "%tty_driver%",
                    "%tty_operations%"
                  ],
                  "peers": [
                    "functions models/tty_unregister_driver"
                  ]
                },
                "free": {
                  "comment": "Free memory of file structure.",
                  "statements": [
                    "$FREE(%file%);"
                  ]
                },
                "init": {
                  "comment": "Allocate memory for file structure.",
                  "statements": [
                    "%file% = $ALLOC(%file%);"
                  ]
                },
                "install_33": {
                  "comment": "Install a new tty into the tty driver internal tables. Invoke callback install from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"%ret% = ldv_emg_wrapper_serial_install_14(%tty_driver%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"install\"} */",
                    "%ret% = ldv_emg_wrapper_serial_install_14(%tty_driver%, %tty_struct%);",
                    "/* Callback post-call */",
                    "%ret% = ldv_filter_err_code(%ret%);"
                  ]
                },
                "install_failed": {
                  "comment": "Failed to install a new tty into the tty driver internal tables.",
                  "condition": [
                    "%ret% != 0"
                  ]
                },
                "install_success": {
                  "comment": "Successfully installed a new tty into the tty driver internal tables.",
                  "condition": [
                    "%ret% == 0"
                  ]
                },
                "lookup_32": {
                  "comment": "Return the tty device corresponding to idx. Invoke callback lookup from TTY.",
                  "entry point": true,
                  "statements": [
                    "if (%tty_operations%->lookup) {",
                    "\t/* Callback pre-call */",
                    "\t/* Expect that tty_mutex is locked */",
                    "\t/* LDV {\"call\": \"%tty_struct% = %tty_operations%->lookup(%tty_driver%, %ldv_param_1_13%, %ldv_param_2_14%);\", \"type\": \"CALLBACK\", \"comment\": \"lookup\"} */",
                    "\t%tty_struct% = %tty_operations%->lookup(%tty_driver%, %ldv_param_1_13%, %ldv_param_2_14%);",
                    "} else {",
                    "\t%tty_struct% = ldv_undef_ptr();",
                    "}"
                  ]
                },
                "main": {
                  "comment": "Install tty or deregister.",
                  "process": "<pre_call_30>.<lookup_32>.<post_call_31>.<install_33>.(<install_success>.<open_35>.(<open_success>.{call} | <open_failed>.<remove_34>) | <install_failed>).{main} | <free>.(deregister)"
                },
                "open_35": {
                  "comment": "Open a tty device. Invoke callback open from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* LDV {\"call\": \"%ret% = ldv_emg_wrapper_serial_open_15(%tty_struct%, %file%);\", \"type\": \"CALLBACK\", \"comment\": \"open\"} */",
                    "%ret% = ldv_emg_wrapper_serial_open_15(%tty_struct%, %file%);",
                    "/* Callback post-call */",
                    "%ret% = ldv_filter_err_code(%ret%);"
                  ]
                },
                "open_failed": {
                  "comment": "Failed to open a particular tty device.",
                  "condition": [
                    "%ret% != 0"
                  ]
                },
                "open_success": {
                  "comment": "Successfully opened a particular tty device.",
                  "condition": [
                    "%ret% == 0"
                  ]
                },
                "post_call_12": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_0_4%);"
                  ]
                },
                "post_call_16": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_2_6%);",
                    "$FREE(%ldv_param_1_5%);"
                  ]
                },
                "post_call_19": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_2_8%);",
                    "$FREE(%ldv_param_1_7%);"
                  ]
                },
                "post_call_22": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_9%);"
                  ]
                },
                "post_call_25": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_0_10%);"
                  ]
                },
                "post_call_28": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_11%);",
                    "$FREE(%ldv_param_2_12%);"
                  ]
                },
                "post_call_31": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_13%);",
                    "$FREE(%ldv_param_2_14%);"
                  ]
                },
                "post_call_37": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_15%);"
                  ]
                },
                "post_call_4": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_2%);"
                  ]
                },
                "post_call_42": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_16%);"
                  ]
                },
                "post_call_45": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_17%);"
                  ]
                },
                "post_call_8": {
                  "comment": "Free memory of adhoc callback parameters.",
                  "statements": [
                    "$FREE(%ldv_param_1_3%);"
                  ]
                },
                "pre_call_11": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_0_4% = $UALLOC(%ldv_param_0_4%);"
                  ]
                },
                "pre_call_15": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_2_6% = $UALLOC(%ldv_param_2_6%);",
                    "%ldv_param_1_5% = $UALLOC(%ldv_param_1_5%);"
                  ]
                },
                "pre_call_18": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_2_8% = $UALLOC(%ldv_param_2_8%);",
                    "%ldv_param_1_7% = $UALLOC(%ldv_param_1_7%);"
                  ]
                },
                "pre_call_21": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_9% = $UALLOC(%ldv_param_1_9%);"
                  ]
                },
                "pre_call_24": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_0_10% = $UALLOC(%ldv_param_0_10%);"
                  ]
                },
                "pre_call_27": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_11% = $UALLOC(%ldv_param_1_11%);",
                    "%ldv_param_2_12% = $UALLOC(%ldv_param_2_12%);"
                  ]
                },
                "pre_call_3": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_2% = $UALLOC(%ldv_param_1_2%);"
                  ]
                },
                "pre_call_30": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_13% = $UALLOC(%ldv_param_1_13%);",
                    "%ldv_param_2_14% = $UALLOC(%ldv_param_2_14%);"
                  ]
                },
                "pre_call_36": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_15% = $UALLOC(%ldv_param_1_15%);"
                  ]
                },
                "pre_call_41": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_16% = $UALLOC(%ldv_param_1_16%);"
                  ]
                },
                "pre_call_44": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_17% = $UALLOC(%ldv_param_1_17%);"
                  ]
                },
                "pre_call_7": {
                  "comment": "Allocate memory for adhoc callback parameters.",
                  "statements": [
                    "%ldv_param_1_3% = $UALLOC(%ldv_param_1_3%);"
                  ]
                },
                "register": {
                  "comment": "Begin {} callbacks invocations scenario.",
                  "condition": [
                    "$ARG2 == ldv_emg_alias_serial_ops_2"
                  ],
                  "parameters": [
                    "%tty_driver%",
                    "%tty_operations%"
                  ],
                  "peers": [
                    "functions models/tty_register_driver"
                  ],
                  "replicative": true
                },
                "remove_34": {
                  "comment": "Remove a closed tty from the tty driver internal tables. Invoke callback remove from TTY.",
                  "entry point": true,
                  "statements": [
                    "if (%tty_operations%->remove) {",
                    "\t/* LDV {\"call\": \"%tty_operations%->remove(%tty_driver%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"remove\"} */",
                    "\t%tty_operations%->remove(%tty_driver%, %tty_struct%);",
                    "}"
                  ]
                },
                "set_termios_43": {
                  "comment": "Device's termios settings have changed. Invoke callback set_termios from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* Callback pre-call */",
                    "/* Expect that termios mutex is locked */",
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_set_termios_18(%tty_struct%, %ldv_param_1_16%);\", \"type\": \"CALLBACK\", \"comment\": \"set_termios\"} */",
                    "ldv_emg_wrapper_serial_set_termios_18(%tty_struct%, %ldv_param_1_16%);"
                  ]
                },
                "set_termiox_46": {
                  "comment": "The device receives a termiox based ioctl. Invoke callback set_termiox from TTY.",
                  "entry point": true,
                  "statements": [
                    "if (%tty_operations%->set_termiox) {",
                    "\t/* Callback pre-call */",
                    "\t/* Expect that termios mutex is locked */",
                    "\t/* LDV {\"call\": \"%tty_operations%->set_termiox(%tty_struct%, %ldv_param_1_17%);\", \"type\": \"CALLBACK\", \"comment\": \"set_termiox\"} */",
                    "\t%tty_operations%->set_termiox(%tty_struct%, %ldv_param_1_17%);",
                    "}"
                  ]
                },
                "shutdown_39": {
                  "comment": "Close a tty device for the last time. Invoke callback shutdown from TTY.",
                  "entry point": true,
                  "statements": [
                    "if (%tty_operations%->shutdown) {",
                    "\t/* Callback pre-call */",
                    "\t/* Expect that tty_mutex is locked */",
                    "\t/* LDV {\"call\": \"%tty_operations%->shutdown(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"shutdown\"} */",
                    "\t%tty_operations%->shutdown(%tty_struct%);",
                    "}"
                  ]
                },
                "start_49": {
                  "comment": "Resume sending characters to tty device. Invoke callback start from TTY.",
                  "entry point": true,
                  "statements": [
                    "if (%tty_operations%->start) {",
                    "\t/* LDV {\"call\": \"%tty_operations%->start(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"start\"} */",
                    "\t%tty_operations%->start(%tty_struct%);",
                    "}"
                  ]
                },
                "stop_50": {
                  "comment": "Stop outputting characters to the tty device Invoke callback stop from TTY.",
                  "entry point": true,
                  "statements": [
                    "if (%tty_operations%->stop) {",
                    "\t/* LDV {\"call\": \"%tty_operations%->stop(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"stop\"} */",
                    "\t%tty_operations%->stop(%tty_struct%);",
                    "}"
                  ]
                },
                "throttle_47": {
                  "comment": "Input buffers for the line discipline are close to full. Invoke callback throttle from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* Callback pre-call */",
                    "/* Expect that termios mutex is locked */",
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_throttle_19(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"throttle\"} */",
                    "ldv_emg_wrapper_serial_throttle_19(%tty_struct%);"
                  ]
                },
                "unthrottle_48": {
                  "comment": "Characters can now be sent to the tty without fear of overrunning the input buffers of the line disciplines. Invoke callback unthrottle from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* Callback pre-call */",
                    "/* Expect that termios mutex is locked */",
                    "/* LDV {\"call\": \"ldv_emg_wrapper_serial_unthrottle_20(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                    "ldv_emg_wrapper_serial_unthrottle_20(%tty_struct%);"
                  ]
                },
                "seq_ops": {
                  "comment": "Characters can now be sent to the tty without fear of overrunning the input buffers of the line disciplines. Invoke callback unthrottle from tty_operations.",
                  "entry point": true,
                  "statements": [
                    "/* Callback pre-call */",
                    "%inode% = $UALLOC(%inode%);",
                    "/* LDV {\"call\": \"ldv_wrapper_serial_proc_open(%inode%, %file%);\", \"type\": \"CALLBACK\", \"comment\": \"proce_open\"} */",
                    "ldv_wrapper_serial_proc_open(%inode%, %file%);",
                    "/* LDV {\"call\": \"ldv_wrapper_serial_proc_show(0, 0);\", \"type\": \"CALLBACK\", \"comment\": \"show\"} */",
                    "ldv_wrapper_serial_proc_show(0, 0);",
                    "/* Callback post-call */",
                    "$FREE(%inode%);"
                  ]
                }
              },
              "category": "tty",
              "comment": "Invoke tty callbacks (Relevant to 'serial_ops')",
              "declarations": {
                "environment model": {
                  "serial_break": "extern int ldv_emg_wrapper_serial_break_3(struct tty_struct *, int);\n",
                  "serial_chars_in_buffer": "extern int ldv_emg_wrapper_serial_chars_in_buffer_4(struct tty_struct *);\n",
                  "serial_cleanup": "extern void ldv_emg_wrapper_serial_cleanup_17(struct tty_struct *);\n",
                  "serial_close": "extern void ldv_emg_wrapper_serial_close_16(struct tty_struct *, struct file *);\n",
                  "serial_get_icount": "extern int ldv_emg_wrapper_serial_get_icount_5(struct tty_struct *, struct serial_icounter_struct *);\n",
                  "serial_hangup": "extern void ldv_emg_wrapper_serial_hangup_8(struct tty_struct *);\n",
                  "serial_install": "extern int ldv_emg_wrapper_serial_install_14(struct tty_driver *, struct tty_struct *);\n",
                  "serial_ioctl": "extern int ldv_emg_wrapper_serial_ioctl_13(struct tty_struct *, unsigned int, long unsigned int);\n",
                  "serial_open": "extern int ldv_emg_wrapper_serial_open_15(struct tty_struct *, struct file *);\n",
                  "serial_port_activate": "extern int ldv_emg_wrapper_serial_port_activate_7(struct tty_port *, struct tty_struct *);\n",
                  "serial_port_shutdown": "extern void ldv_emg_wrapper_serial_port_shutdown_12(struct tty_port *);\n",
                  "serial_set_termios": "extern void ldv_emg_wrapper_serial_set_termios_18(struct tty_struct *, struct ktermios *);\n",
                  "serial_throttle": "extern void ldv_emg_wrapper_serial_throttle_19(struct tty_struct *);\n",
                  "serial_tiocmget": "extern int ldv_emg_wrapper_serial_tiocmget_2(struct tty_struct *);\n",
                  "serial_tiocmset": "extern int ldv_emg_wrapper_serial_tiocmset_10(struct tty_struct *, unsigned int, unsigned int);\n",
                  "serial_unthrottle": "extern void ldv_emg_wrapper_serial_unthrottle_20(struct tty_struct *);\n",
                  "serial_wait_until_sent": "extern void ldv_emg_wrapper_serial_wait_until_sent_11(struct tty_struct *, int);\n",
                  "serial_write": "extern int ldv_emg_wrapper_serial_write_9(struct tty_struct *, unsigned char *, int);\n",
                  "serial_write_room": "extern int ldv_emg_wrapper_serial_write_room_6(struct tty_struct *);\n",
                  "serial_proc_show": "extern int ldv_wrapper_serial_proc_show(struct seq_file *m, void *v);\n",
                  "serial_proc_open": "extern int ldv_wrapper_serial_proc_open(struct inode *inode, struct file *file);\n"
                }
              },
              "definitions": {
                "drivers/usb/serial/usb-serial.c": {
                  "serial_proc_show": [
                    "/* AUX_FUNC ldv_wrapper_serial_proc_show */\n",
                    "int ldv_wrapper_serial_proc_show(struct seq_file *m, void *v) {\n",
                    "\treturn serial_proc_show(m, v);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_proc_open": [
                    "/* AUX_FUNC ldv_wrapper_serial_proc_open */\n",
                    "int ldv_wrapper_serial_proc_open(struct inode *inode, struct file *file) {\n",
                    "\treturn serial_proc_open(inode, file);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_break": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_break_3 */\n",
                    "int ldv_emg_wrapper_serial_break_3(struct tty_struct *arg0, int arg1) {\n",
                    "\treturn serial_break(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_chars_in_buffer": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_chars_in_buffer_4 */\n",
                    "int ldv_emg_wrapper_serial_chars_in_buffer_4(struct tty_struct *arg0) {\n",
                    "\treturn serial_chars_in_buffer(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_cleanup": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_cleanup_17 */\n",
                    "void ldv_emg_wrapper_serial_cleanup_17(struct tty_struct *arg0) {\n",
                    "\t serial_cleanup(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_close": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_close_16 */\n",
                    "void ldv_emg_wrapper_serial_close_16(struct tty_struct *arg0, struct file *arg1) {\n",
                    "\t serial_close(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_get_icount": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_get_icount_5 */\n",
                    "int ldv_emg_wrapper_serial_get_icount_5(struct tty_struct *arg0, struct serial_icounter_struct *arg1) {\n",
                    "\treturn serial_get_icount(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_hangup": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_hangup_8 */\n",
                    "void ldv_emg_wrapper_serial_hangup_8(struct tty_struct *arg0) {\n",
                    "\t serial_hangup(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_install": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_install_14 */\n",
                    "int ldv_emg_wrapper_serial_install_14(struct tty_driver *arg0, struct tty_struct *arg1) {\n",
                    "\treturn serial_install(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_ioctl": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_ioctl_13 */\n",
                    "int ldv_emg_wrapper_serial_ioctl_13(struct tty_struct *arg0, unsigned int arg1, long unsigned int arg2) {\n",
                    "\treturn serial_ioctl(arg0, arg1, arg2);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_open": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_open_15 */\n",
                    "int ldv_emg_wrapper_serial_open_15(struct tty_struct *arg0, struct file *arg1) {\n",
                    "\treturn serial_open(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_port_activate": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_port_activate_7 */\n",
                    "int ldv_emg_wrapper_serial_port_activate_7(struct tty_port *arg0, struct tty_struct *arg1) {\n",
                    "\treturn serial_port_activate(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_port_shutdown": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_port_shutdown_12 */\n",
                    "void ldv_emg_wrapper_serial_port_shutdown_12(struct tty_port *arg0) {\n",
                    "\t serial_port_shutdown(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_set_termios": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_set_termios_18 */\n",
                    "void ldv_emg_wrapper_serial_set_termios_18(struct tty_struct *arg0, struct ktermios *arg1) {\n",
                    "\t serial_set_termios(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_throttle": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_throttle_19 */\n",
                    "void ldv_emg_wrapper_serial_throttle_19(struct tty_struct *arg0) {\n",
                    "\t serial_throttle(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_tiocmget": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_tiocmget_2 */\n",
                    "int ldv_emg_wrapper_serial_tiocmget_2(struct tty_struct *arg0) {\n",
                    "\treturn serial_tiocmget(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_tiocmset": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_tiocmset_10 */\n",
                    "int ldv_emg_wrapper_serial_tiocmset_10(struct tty_struct *arg0, unsigned int arg1, unsigned int arg2) {\n",
                    "\treturn serial_tiocmset(arg0, arg1, arg2);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_unthrottle": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_unthrottle_20 */\n",
                    "void ldv_emg_wrapper_serial_unthrottle_20(struct tty_struct *arg0) {\n",
                    "\t serial_unthrottle(arg0);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_wait_until_sent": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_wait_until_sent_11 */\n",
                    "void ldv_emg_wrapper_serial_wait_until_sent_11(struct tty_struct *arg0, int arg1) {\n",
                    "\t serial_wait_until_sent(arg0, arg1);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_write": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_write_9 */\n",
                    "int ldv_emg_wrapper_serial_write_9(struct tty_struct *arg0, unsigned char *arg1, int arg2) {\n",
                    "\treturn serial_write(arg0, arg1, arg2);\n",
                    "}\n",
                    "\n"
                  ],
                  "serial_write_room": [
                    "/* AUX_FUNC ldv_emg_wrapper_serial_write_room_6 */\n",
                    "int ldv_emg_wrapper_serial_write_room_6(struct tty_struct *arg0) {\n",
                    "\treturn serial_write_room(arg0);\n",
                    "}\n",
                    "\n"
                  ]
                }
              },
              "headers": [
                "linux/tty.h",
                "linux/tty_driver.h",
                "linux/fs.h"
              ],
              "identifier": "tty/tty_scenario/serial_ops",
              "labels": {
                "inode": {
                  "declaration": "struct inode *inode"
                },
                "file": {
                  "declaration": "struct file *file"
                },
                "ldv_param_0_10": {
                  "declaration": "struct tty_port *ldv_param_0_10"
                },
                "ldv_param_0_4": {
                  "declaration": "struct tty_port *ldv_param_0_4"
                },
                "ldv_param_1_11": {
                  "declaration": "unsigned int ldv_param_1_11"
                },
                "ldv_param_1_13": {
                  "declaration": "struct inode *ldv_param_1_13"
                },
                "ldv_param_1_15": {
                  "declaration": "struct file *ldv_param_1_15"
                },
                "ldv_param_1_16": {
                  "declaration": "struct ktermios *ldv_param_1_16"
                },
                "ldv_param_1_17": {
                  "declaration": "struct termiox *ldv_param_1_17"
                },
                "ldv_param_1_2": {
                  "declaration": "int ldv_param_1_2"
                },
                "ldv_param_1_3": {
                  "declaration": "struct serial_icounter_struct *ldv_param_1_3"
                },
                "ldv_param_1_5": {
                  "declaration": "unsigned char *ldv_param_1_5"
                },
                "ldv_param_1_7": {
                  "declaration": "unsigned int ldv_param_1_7"
                },
                "ldv_param_1_9": {
                  "declaration": "int ldv_param_1_9"
                },
                "ldv_param_2_12": {
                  "declaration": "long unsigned int ldv_param_2_12"
                },
                "ldv_param_2_14": {
                  "declaration": "int ldv_param_2_14"
                },
                "ldv_param_2_6": {
                  "declaration": "int ldv_param_2_6"
                },
                "ldv_param_2_8": {
                  "declaration": "unsigned int ldv_param_2_8"
                },
                "ret": {
                  "declaration": "int ret",
                  "value": "1"
                },
                "tty_driver": {
                  "declaration": "struct tty_driver *tty_driver"
                },
                "tty_operations": {
                  "declaration": "struct tty_operations *tty_operations",
                  "value": "ldv_emg_alias_serial_ops_2"
                },
                "tty_struct": {
                  "declaration": "struct tty_struct *tty_struct"
                }
              },
              "process": "(!register).<init>.{main}"
            }
          }
        }
      }
    ]
  }
}