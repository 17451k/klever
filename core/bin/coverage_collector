#!/usr/bin/env python3
#
# Copyright (c) 2014-2015 ISPRAS (http://www.ispras.ru)
# Institute for System Programming of the Russian Academy of Sciences
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import os
import logging
import argparse


def cut_work_dirs(line, linux):
    """
    Fix the given line from a coverage file to remove absolute path.

    :param line: String.
    :param linux: Absolute path to the Linux source dir.
    :return: Fixed line.
    """
    rline = line.rstrip('\n')
    path = rline[len('SF:'):]
    if path.startswith(linux):
        newpath = path[(len(linux) + 1):]
        line = line.replace(path, newpath)
    return line


def move_content(linux, covfile, outfile):
    """
    Move content from coverage file to a final output file. The function just appends a given file to the output one.
    Also it changes absolute paths to relative ones.

    :param linux: Path to a Linux sources directory.
    :param covfile: Path to a coverage file.
    :param outfile: Path to an out file.
    """
    with open(outfile, 'a', encoding='utf8') as outfp, open(covfile, 'r', encoding='utf8') as covfp:
        for line in covfp:
            if line.startswith('SF:'):
                line = cut_work_dirs(line, linux)
            outfp.write(line)


def search_files(directory):
    """
    This is an iterator that searches for coverage raw format files from Klever working directory and return paths
    to them.

    :param directory: Absolute path to a Klever working directory.
    :return: File paths.
    """
    logging.info("Search for coverage files in {!r}".format(directory))
    files_cnt = 0
    for root, _, files in os.walk(directory):
        if 'coverage.info' in files:
            files_cnt += 1
            yield os.path.join(root, "coverage.info")
    logging.info("Collected totally {} coverage files".format(files_cnt))


def check_dir(workdir, linuxdir, outfile):
    """
    Just check that necessary directories exist and covert the path to Klever working directory to an absolute one.

    :param workdir: Path to a Klever working directory.
    :param linuxdir: Path to a Linux sources directory.
    :param outfile: Path to an output file.
    :return: Absolute path to a Klever working directory.
    """
    # Get absolute path as it is expected. Check that directory is exist
    awork = os.path.abspath(workdir)
    alinux = os.path.abspath(linuxdir)

    if not os.path.isdir(awork):
        raise ValueError("Please provide correct existing directory path to the Klever working directory")
    if not os.path.isdir(alinux):
        raise ValueError("Please provide correct existing directory path to the Linux source directory")
    if os.path.isfile(outfile):
        logging.warning("Rewriting an existing file with coverage: {!r}.".format(outfile))
        os.remove(outfile)

    return awork


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Search for coverage in a raw format in a Klever job working directory'
                                                 ' and merge it into a single file. The coverage is required for Linux '
                                                 'kernel subsystems verification with "coverage" LKVOG strategy.')
    parser.add_argument('workdir', metavar="workdir", help='Path to a working directory with the collected coverage.')
    parser.add_argument('linux', metavar="linux", help='Path to a Linux source directory used at verification.')
    parser.add_argument('outfile', metavar="outfile", help='A file name to save collected coverage.')
    args = parser.parse_args()

    apath = check_dir(args.workdir, args.linux, args.outfile)
    for file in search_files(apath):
        move_content(args.linux, file, args.outfile)

    logging.info("Finish coverage collecting. Now you can provide generated file {!r} to LKVOG strategy for kernel "
                 "subsystems verification".format(args.outfile))
