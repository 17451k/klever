#include <linux/mutex.h>
#include <verifier/rcv.h>
#include <verifier/set.h>

// for arg_sign in mutex_arg_signs
Set LDV_MUTEXES{{ arg_sign.id }};

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was unlocked and nondeterministically lock it. Return the corresponding error code on fails */
int ldv_mutex_lock_interruptible{{ arg_sign.id }}(struct mutex *lock)
{
	int nondetermined;

	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked */
	ldv_assert("linux:mutex::one thread:double lock", !ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock));

	/* OTHER Construct nondetermined result*/
	nondetermined = ldv_undef_int();

	/* ASSERT Nondeterministically lock mutex{{ arg_sign.text }} */
	if (nondetermined)
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_set_add(LDV_MUTEXES{{ arg_sign.id }}, lock);
		/* RETURN Finish with success */
		return 0;
	}
	else
	{
		/* RETURN Finish with fail. Mutex{{ arg_sign.text }} is keeped unlocked */
		return -EINTR;
	}
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} wasn unlocked and nondeterministically lock it. Return the corresponding error code on fails */
int ldv_mutex_lock_killable{{ arg_sign.id }}(struct mutex *lock)
{
	int nondetermined;

	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked */
	ldv_assert("linux:mutex::one thread:double lock", !ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock));

	/* OTHER Construct nondetermined result */
	nondetermined = ldv_undef_int();

	/* ASSERT Nondeterministically lock mutex{{ arg_sign.text }} */
	if (nondetermined)
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_set_add(LDV_MUTEXES{{ arg_sign.id }}, lock);
		/* RETURN Finish with success */
		return 0;
	}
	else
	{
		/* RETURN Finish with the fail. Mutex{{ arg_sign.text }} is keeped unlocked */
		return -EINTR;
	}
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was not locked and lock it */
void ldv_mutex_lock{{ arg_sign.id }}(struct mutex *lock)
{
	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked */
	ldv_assert("linux:mutex::one thread:double lock", !ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock));
	/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
	ldv_set_add(LDV_MUTEXES{{ arg_sign.id }}, lock);
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was not locked and nondeterministically lock it. Return 0 on fails */
int ldv_mutex_trylock{{ arg_sign.id }}(struct mutex *lock)
{
	int is_mutex_held_by_another_thread;

	/* ASSERT It may be an error if mutex{{ arg_sign.text }} is locked at this point */
	ldv_assert("linux:mutex::one thread:double lock", !ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock));

	/* OTHER Construct nondetermined result */
	is_mutex_held_by_another_thread = ldv_undef_int();

	/* ASSERT Nondeterministically lock mutex{{ arg_sign.text }} */
	if (is_mutex_held_by_another_thread)
	{
		/* RETURN Finish with fail */
		return 0;
	}
	else
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_set_add(LDV_MUTEXES{{ arg_sign.id }}, lock);
		/* RETURN Finish with success */
		return 1;
	}
}

/* MODEL_FUNC_DEF Lock mutex{{ arg_sign.text }} if atomic decrement result is zero */
int ldv_atomic_dec_and_mutex_lock{{ arg_sign.id }}(atomic_t *cnt, struct mutex *lock)
{
	int atomic_value_after_dec;

	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked (since we may lock it in this function) */
	ldv_assert("linux:mutex::one thread:double lock", !ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock));

	/* OTHER Assign the result of atomic decrement */
	atomic_value_after_dec = ldv_undef_int();

	/* ASSERT Check if atomic decrement returns zero */
	if (atomic_value_after_dec == 0)
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }}, as atomic has decremented to zero */
		ldv_set_add(LDV_MUTEXES{{ arg_sign.id }}, lock);
		/* RETURN Return 1 with locked mutex{{ arg_sign.text }} */
		return 1;
	}

	/* RETURN Atomic decrement is still not zero, return 0 without locking mutex{{ arg_sign.text }} */
	return 0;
}

/* TODO Syncronize with 39_7a ldv_spin_is_locked! */
/* MODEL_FUNC_DEF Check whether mutex{{ arg_sign.text }} was locked */
int ldv_mutex_is_locked{{ arg_sign.id }}(struct mutex *lock)
{
	int nondetermined;

	if (ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock))
	{
		/* OTHER Construct nondetermined result */
		nondetermined = ldv_undef_int();

		/* ASSERT Nondeterministically understand whether mutex{{ arg_sign.text }} was locked */
		if(nondetermined)
		{
			/* RETURN Mutex{{ arg_sign.text }} was unlocked */
			return 0;
		}
		else
		{
			/* RETURN Mutex{{ arg_sign.text }} was locked */
			return 1;
		}
	}
	else
	{
		/* RETURN Mutex{{ arg_sign.text }} was locked */
		return 1;
	}
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was locked and unlock it */
void ldv_mutex_unlock{{ arg_sign.id }}(struct mutex *lock)
{
	/* ASSERT Mutex{{ arg_sign.text }} must be locked */
	ldv_assert("linux:mutex::one thread:double unlock", ldv_set_contains(LDV_MUTEXES{{ arg_sign.id }}, lock));
	/* CHANGE_STATE Unlock mutex{{ arg_sign.text }} */
	ldv_set_remove(LDV_MUTEXES{{ arg_sign.id }}, lock);
}
// endfor

/* MODEL_FUNC_DEF Make all mutexes unlocked at the beginning */
void ldv_initialize(void)
{
	// for arg_sign in mutex_arg_signs
	/* CHANGE_STATE Mutex{{ arg_sign.text }} is unlocked at the beginning */
	ldv_set_init(LDV_MUTEXES{{ arg_sign.id }});
	// endfor
}

/* MODEL_FUNC_DEF Check that all mutexes are unlocked at the end */
void ldv_check_final_state(void)
{
	// for arg_sign in mutex_arg_signs
	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked at the end */
	ldv_assert("linux:mutex::one thread:locked at exit", ldv_set_is_empty(LDV_MUTEXES{{ arg_sign.id }}));
	// endfor
}
