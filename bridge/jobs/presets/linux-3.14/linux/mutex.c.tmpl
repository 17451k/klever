#include <linux/mutex.h>
#include <linux/errno.h>
#include <verifier/rcv.h>

// for arg_sign in mutex_arg_signs
static int ldv_mutex{{ arg_sign.id }} = 1;

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was unlocked and nondeterministically lock it. Return the corresponding error code on fails */
int ldv_mutex_lock_interruptible{{ arg_sign.id }}(struct mutex *lock)
{
	int nondetermined;

	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked */
	ldv_assert("linux:mutex::one thread:double lock", ldv_mutex{{ arg_sign.id }} == 1);

	/* OTHER Construct nondetermined result*/
	nondetermined = ldv_undef_int();

	/* ASSERT Nondeterministically lock mutex{{ arg_sign.text }} */
	if (nondetermined)
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_mutex{{ arg_sign.id }} = 2;
		/* RETURN Finish with success */
		return 0;
	}
	else
	{
		/* RETURN Finish with fail. Mutex{{ arg_sign.text }} is keeped unlocked */
		return -EINTR;
	}
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} wasn unlocked and nondeterministically lock it. Return the corresponding error code on fails */
int ldv_mutex_lock_killable{{ arg_sign.id }}(struct mutex *lock)
{
	int nondetermined;

	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked */
	ldv_assert("linux:mutex::one thread:double lock", ldv_mutex{{ arg_sign.id }} == 1);

	/* OTHER Construct nondetermined result */
	nondetermined = ldv_undef_int();

	/* ASSERT Nondeterministically lock mutex{{ arg_sign.text }} */
	if (nondetermined)
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_mutex{{ arg_sign.id }} = 2;
		/* RETURN Finish with success */
		return 0;
	}
	else
	{
		/* RETURN Finish with the fail. Mutex{{ arg_sign.text }} is keeped unlocked */
		return -EINTR;
	}
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was not locked and lock it */
void ldv_mutex_lock{{ arg_sign.id }}(struct mutex *lock)
{
	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked */
	ldv_assert("linux:mutex::one thread:double lock", ldv_mutex{{ arg_sign.id }} == 1);
	/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
	ldv_mutex{{ arg_sign.id }} = 2;
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was not locked and nondeterministically lock it. Return 0 on fails */
int ldv_mutex_trylock{{ arg_sign.id }}(struct mutex *lock)
{
	int is_mutex_held_by_another_thread;

	/* ASSERT It may be an error if mutex{{ arg_sign.text }} is locked at this point */
	ldv_assert("linux:mutex::one thread:double lock", ldv_mutex{{ arg_sign.id }} == 1);

	/* OTHER Construct nondetermined result */
	is_mutex_held_by_another_thread = ldv_undef_int();

	/* ASSERT Nondeterministically lock mutex{{ arg_sign.text }} */
	if (is_mutex_held_by_another_thread)
	{
		/* RETURN Finish with fail */
		return 0;
	}
	else
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_mutex{{ arg_sign.id }} = 2;
		/* RETURN Finish with success */
		return 1;
	}
}

/* MODEL_FUNC_DEF Lock mutex{{ arg_sign.text }} if atomic decrement result is zero */
int ldv_atomic_dec_and_mutex_lock{{ arg_sign.id }}(atomic_t *cnt, struct mutex *lock)
{
	int atomic_value_after_dec;

	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked (since we may lock it in this function) */
	ldv_assert("linux:mutex::one thread:double lock", ldv_mutex{{ arg_sign.id }} == 1);

	/* OTHER Assign the result of atomic decrement */
	atomic_value_after_dec = ldv_undef_int();

	/* ASSERT Check if atomic decrement returns zero */
	if (atomic_value_after_dec == 0)
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }}, as atomic has decremented to zero */
		ldv_mutex{{ arg_sign.id }} = 2;
		/* RETURN Return 1 with locked mutex{{ arg_sign.text }} */
		return 1;
	}

	/* RETURN Atomic decrement is still not zero, return 0 without locking mutex{{ arg_sign.text }} */
	return 0;
}

/* TODO Syncronize with 39_7a ldv_spin_is_locked! */
/* MODEL_FUNC_DEF Check whether mutex{{ arg_sign.text }} was locked */
int ldv_mutex_is_locked{{ arg_sign.id }}(struct mutex *lock)
{
	int nondetermined;

	if(ldv_mutex{{ arg_sign.id }} == 1)
	{
		/* OTHER Construct nondetermined result */
		nondetermined = ldv_undef_int();

		/* ASSERT Nondeterministically understand whether mutex{{ arg_sign.text }} was locked */
		if(nondetermined)
		{
			/* RETURN Mutex{{ arg_sign.text }} was unlocked */
			return 0;
		}
		else
		{
			/* RETURN Mutex{{ arg_sign.text }} was locked */
			return 1;
		}
	}
	else
	{
		/* RETURN Mutex{{ arg_sign.text }} was locked */
		return 1;
	}
}

/* MODEL_FUNC_DEF Check that mutex{{ arg_sign.text }} was locked and unlock it */
void ldv_mutex_unlock{{ arg_sign.id }}(struct mutex *lock)
{
	/* ASSERT Mutex{{ arg_sign.text }} must be locked */
	ldv_assert("linux:mutex::one thread:double unlock", ldv_mutex{{ arg_sign.id }} == 2);
	/* CHANGE_STATE Unlock mutex{{ arg_sign.text }} */
	ldv_mutex{{ arg_sign.id }} = 1;
}

/* MODEL_FUNC_DEF Acquires the usb lock and checks for double usb lock */
void ldv_usb_lock_device{{ arg_sign.id }}(void)
{
	/* CHANGE_STATE Lock usb_lock{{ arg_sign.text }} */
	ldv_mutex_lock{{ arg_sign.id }}(NULL);
}

/* MODEL_FUNC_DEF Tries to acquire the usb lock and returns 1 if successful */
int ldv_usb_trylock_device{{ arg_sign.id }}(void)
{
	return ldv_mutex_trylock{{ arg_sign.id }}(NULL);
}

/* MODEL_FUNC_DEF Tries to acquire the usb lock and returns 0 if successful */
int ldv_usb_lock_device_for_reset{{ arg_sign.id }}(void)
{
	if(ldv_undef_int())
	{
		/* CHANGE_STATE Lock mutex{{ arg_sign.text }} */
		ldv_mutex_lock{{ arg_sign.id }}(NULL);
		/* RETURN Finish with success */
		return 0;
	} else
	/* RETURN Usb lock is not acquired*/
	return ldv_undef_int_negative();
}

/* MODEL_FUNC_DEF Releases the usb lock and checks that usb lock was acquired before */
void ldv_usb_unlock_device{{ arg_sign.id }}(void)
{
	/* CHANGE_STATE Unlock usb_lock{{ arg_sign.text }} */
	ldv_mutex_unlock{{ arg_sign.id }}(NULL);
}
// endfor

/* MODEL_FUNC_DEF Check that all mutexes are unlocked at the end */
void ldv_check_final_state(void)
{
	// for arg_sign in mutex_arg_signs
	/* ASSERT Mutex{{ arg_sign.text }} must be unlocked at the end */
	ldv_assert("linux:mutex::one thread:locked at exit", ldv_mutex{{ arg_sign.id }} == 1);
	// endfor
}
