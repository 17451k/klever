before: file ("$this")
{
struct module;

extern int ldv_try_module_get(struct module *);
extern void ldv_module_get(struct module *);
extern void ldv_module_put(struct module *);
extern unsigned int ldv_module_refcount(struct module *);
extern void ldv_module_put_and_exit(void);
}

around: execution(static inline int try_module_get(..)) ||
        call(bool try_module_get(..))
{
	/* ASPECT_FUNC_CALL Nondeterministically increment module reference counter unless module pointer is NULL */
	return ldv_try_module_get($arg1);
}

around: execution(static inline void __module_get(..)) ||
        call(void __module_get(..))
{
	/* ASPECT_FUNC_CALL Increment module reference counter unless module pointer is NULL */
	ldv_module_get($arg1);
}

around: call(void module_put(..)) ||
        execution(static inline void module_put(..))
{
	/* ASPECT_FUNC_CALL Check that module reference counter is greater than its initial state and decrement it */
	ldv_module_put($arg1);
}

around: define(module_put_and_exit(code))
{
ldv_module_put_and_exit();
}

around: call(unsigned int module_refcount(..)) ||
        call(unsigned long module_refcount(..))
{
	/* ASPECT_FUNC_CALL Check that module reference counter is greater than its initial state, decrement it and stop execution */
	return ldv_module_refcount($arg1);
}

/* TODO: how this affects other rule specifications when using multiaspects verification? */
/* nonseekable_open is a generic function, and it always returns zero in addition to setting some flags. For the
 * purpose of this rule specification, we assume it merely returns 0.
 */
around: call(int nonseekable_open(..))
{
	return 0;
}
