/*
 * Copyright (c) 2014-2016 ISPRAS (http://www.ispras.ru)
 * Institute for System Programming of the Russian Academy of Sciences
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * ee the License for the specific language governing permissions and
 * limitations under the License.
 */

before: file("$this")
{
#include <linux/types.h>
#include <verifier/common.h>

@ifdef LDV_LINUX_ALLOC_IRQ
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags);
void ldv_linux_alloc_irq_check_alloc_nonatomic(void);
@endif /* LDV_LINUX_ALLOC_IRQ */

@ifdef LDV_LINUX_ALLOC_USB_LOCK
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags);
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void);
@endif /* LDV_LINUX_ALLOC_USB_LOCK */

@ifdef LDV_LINUX_ARCH_IO
void ldv_linux_arch_io_check_final_state(void);
@endif /* LDV_LINUX_ARCH_IO */

@ifdef LDV_LINUX_BLOCK_GENHD
void ldv_linux_block_genhd_check_final_state(void);
@endif /* LDV_LINUX_BLOCK_GENHD */

@ifdef LDV_LINUX_BLOCK_QUEUE
void ldv_linux_block_queue_check_final_state(void);
@endif /* LDV_LINUX_BLOCK_QUEUE */

@ifdef LDV_LINUX_BLOCK_REQUEST
void ldv_linux_block_request_check_final_state(void);
@endif /* LDV_LINUX_BLOCK_REQUEST */

@ifdef LDV_LINUX_DRIVERS_BASE_CLASS
void *ldv_linux_drivers_base_class_create_class(void);
int ldv_linux_drivers_base_class_register_class(void);
void ldv_linux_drivers_base_class_unregister_class(void);
struct class;
void ldv_linux_drivers_base_class_destroy_class(struct class *cls);
void ldv_linux_drivers_base_class_check_final_state(void);
@endif /* LDV_LINUX_DRIVERS_BASE_CLASS */

@ifdef LDV_LINUX_DRIVERS_BASE_DMA_MAPPING
void ldv_linux_drivers_base_dma_mapping_check_final_state(void);
@endif /* LDV_LINUX_DRIVERS_BASE_DMA_MAPPING */

@ifdef LDV_LINUX_FS_CHAR_DEV
int ldv_linux_fs_char_dev_register_chrdev(int major);
int ldv_linux_fs_char_dev_register_chrdev_region(void);
void ldv_linux_fs_char_dev_unregister_chrdev_region(void);
void ldv_linux_fs_char_dev_check_final_state(void);
@endif /* LDV_LINUX_FS_CHAR_DEV */

@ifdef LDV_LINUX_FS_SYSFS
void ldv_linux_fs_sysfs_check_final_state(void);
@endif /* LDV_LINUX_FS_SYSFS */

@ifdef LDV_LINUX_KERNEL_LOCKING_RWLOCK
void ldv_linux_kernel_locking_rwlock_check_final_state(void);
@endif /* LDV_LINUX_KERNEL_LOCKING_RWLOCK */

@ifdef LDV_LINUX_KERNEL_MODULE
void ldv_linux_kernel_module_check_final_state(void);
@endif /* LDV_LINUX_KERNEL_MODULE */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_BH
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void);
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void);
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_BH */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_SCHED
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void);
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void);
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_SCHED */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void);
void ldv_linux_kernel_rcu_update_lock_check_final_state(void);
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK */

@ifdef LDV_LINUX_KERNEL_RCU_SRCU
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void);
void ldv_linux_kernel_rcu_srcu_check_final_state(void);
@endif /* LDV_LINUX_KERNEL_RCU_SRCU */

@ifdef LDV_LINUX_LIB_FIND_BIT
void ldv_linux_lib_find_bit_initialize(void);
@endif /* LDV_LINUX_LIB_FIND_BIT*/

@ifdef LDV_LINUX_LIB_IDR
void ldv_linux_lib_idr_check_final_state(void);
@endif /* LDV_LINUX_LIB_IDR */

@ifdef LDV_LINUX_MMC_SDIO_FUNC
void ldv_linux_mmc_sdio_func_check_final_state(void);
@endif /* LDV_LINUX_MMC_SDIO_FUNC */

@ifdef LDV_LINUX_NET_REGISTER
void ldv_linux_net_register_reset_error_counter(void);
void ldv_linux_net_register_check_return_value_probe(int retval);
@endif /* LDV_LINUX_NET_REGISTER */

@ifdef LDV_LINUX_NET_RTNETLINK
void ldv_linux_net_rtnetlink_check_final_state(void);
@endif /* LDV_LINUX_NET_RTNETLINK */

@ifdef LDV_LINUX_NET_SOCK
void ldv_linux_net_sock_check_final_state(void);
@endif /* LDV_LINUX_NET_SOCK */

@ifdef LDV_LINUX_USB_COHERENT
void *ldv_linux_usb_coherent_usb_alloc_coherent(void);
void ldv_linux_usb_coherent_check_final_state(void);
@endif /* LDV_LINUX_USB_COHERENT */

@ifdef LDV_LINUX_USB_GADGET
void *ldv_linux_usb_gadget_create_class(void);
int ldv_linux_usb_gadget_register_class(void);
void ldv_linux_usb_gadget_unregister_class(void);
struct class;
void ldv_linux_usb_gadget_destroy_class(struct class *cls);
int ldv_linux_usb_gadget_register_chrdev(int major);
int ldv_linux_usb_gadget_register_chrdev_region(void);
void ldv_linux_usb_gadget_unregister_chrdev_region(void);
void ldv_linux_usb_gadget_check_final_state(void);
@endif /* LDV_LINUX_USB_GADGET */

@ifdef LDV_LINUX_USB_REGISTER
void ldv_linux_usb_register_reset_error_counter(void);
void ldv_linux_usb_register_check_return_value_probe(int retval);
@endif /* LDV_LINUX_USB_REGISTER */

@ifdef LDV_LINUX_USB_URB
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void);
void ldv_linux_usb_urb_check_final_state(void);
@endif /* LDV_LINUX_USB_URB */

/* TODO: move this functions to commmon.c when it will be supported. */
void ldv_check_alloc_nonatomic(void)
{
@ifdef LDV_LINUX_ALLOC_IRQ
	ldv_linux_alloc_irq_check_alloc_nonatomic();
@endif /* LDV_LINUX_ALLOC_IRQ */

@ifdef LDV_LINUX_ALLOC_USB_LOCK
	ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
@endif /* LDV_LINUX_ALLOC_USB_LOCK */
}

void ldv_check_alloc_flags(gfp_t flags)
{
@ifdef LDV_LINUX_ALLOC_IRQ
	ldv_linux_alloc_irq_check_alloc_flags(flags);
@endif /* LDV_LINUX_ALLOC_IRQ */

@ifdef LDV_LINUX_ALLOC_USB_LOCK
	ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
@endif /* LDV_LINUX_ALLOC_USB_LOCK */
}

void ldv_check_for_read_section(void)
{
@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_BH
	ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_BH */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_SCHED
	ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_SCHED */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK
	ldv_linux_kernel_rcu_update_lock_check_for_read_section();
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK */

@ifdef LDV_LINUX_KERNEL_RCU_SRCU
	ldv_linux_kernel_rcu_srcu_check_for_read_section();
@endif /* LDV_LINUX_KERNEL_RCU_SRCU */
}

void *ldv_create_class(void)
{
@if defined(LDV_LINUX_DRIVERS_BASE_CLASS) && defined(LDV_LINUX_USB_GADGET)
	void *res1 = ldv_linux_drivers_base_class_create_class();
	void *res2 = ldv_linux_usb_gadget_create_class();
	ldv_assume(res1 == res2);
	return res1;
@elif defined(LDV_LINUX_DRIVERS_BASE_CLASS)
	return ldv_linux_drivers_base_class_create_class();
@elif defined(LDV_LINUX_USB_GADGET)
	return ldv_linux_usb_gadget_create_class();
@endif /* LDV_LINUX_USB_GADGET */
}

int ldv_register_class(void)
{
@if defined(LDV_LINUX_DRIVERS_BASE_CLASS) && defined(LDV_LINUX_USB_GADGET)
	int res1 = ldv_linux_drivers_base_class_register_class();
	int res2 = ldv_linux_usb_gadget_register_class();
	ldv_assume(res1 == res2);
	return res1;
@elif defined(LDV_LINUX_DRIVERS_BASE_CLASS)
	return ldv_linux_drivers_base_class_register_class();
@elif defined(LDV_LINUX_USB_GADGET)
	return ldv_linux_usb_gadget_register_class();
@endif /* LDV_LINUX_USB_GADGET */
}
}

around: call(void ldv_initialize(void))
{
@ifdef LDV_LINUX_LIB_FIND_BIT
	ldv_linux_lib_find_bit_initialize();
@endif /* LDV_LINUX_LIB_FIND_BIT */
}

before: call(int ldv_post_init(..)) ||
        call(void ldv_pre_probe(..))
{
@ifdef LDV_LINUX_NET_REGISTER
	ldv_linux_net_register_reset_error_counter();
@endif /* LDV_LINUX_NET_REGISTER */

@ifdef LDV_LINUX_USB_REGISTER
	ldv_linux_usb_register_reset_error_counter();
@endif /* LDV_LINUX_USB_REGISTER */
}

before: call(int ldv_post_probe(int retval))
{
@ifdef LDV_LINUX_NET_REGISTER
	ldv_linux_net_register_check_return_value_probe(retval);
@endif /* LDV_LINUX_NET_REGISTER */

@ifdef LDV_LINUX_USB_REGISTER
	ldv_linux_usb_register_check_return_value_probe(retval);
@endif /* LDV_LINUX_USB_REGISTER */
}

@if defined(LDV_LINUX_DRIVERS_BASE_CLASS) || defined(LDV_LINUX_USB_GADGET)
around: define(class_create(owner, name))
{
ldv_create_class()
}

around: define(class_register(class))
{
ldv_register_class()
}
@endif /* LDV_LINUX_DRIVERS_BASE_CLASS || LDV_LINUX_USB_GADGET */

around: call(void class_destroy(struct class *cls))
{
@ifdef LDV_LINUX_DRIVERS_BASE_CLASS
	ldv_linux_drivers_base_class_destroy_class(cls);
@endif /* LDV_LINUX_DRIVERS_BASE_CLASS */

@ifdef LDV_LINUX_USB_GADGET
	ldv_linux_usb_gadget_destroy_class(cls);
@endif /* LDV_LINUX_USB_GADGET */
}

after: call(void class_unregister(..))
{
@ifdef LDV_LINUX_DRIVERS_BASE_CLASS
	ldv_linux_drivers_base_class_unregister_class();
@endif /* LDV_LINUX_DRIVERS_BASE_CLASS */

@ifdef LDV_LINUX_USB_GADGET
	ldv_linux_usb_gadget_unregister_class();
@endif /* LDV_LINUX_USB_GADGET */
}

after: call(int alloc_chrdev_region(..)) ||
       call(int register_chrdev_region(..))
{
@if defined(LDV_LINUX_FS_CHAR_DEV) && defined(LDV_LINUX_USB_GADGET)
	int res1 = ldv_linux_fs_char_dev_register_chrdev_region();
	int res2 = ldv_linux_usb_gadget_register_chrdev_region();
	ldv_assume(res1 == res2);
	return res1;
@elif defined(LDV_LINUX_FS_CHAR_DEV)
	return ldv_linux_fs_char_dev_register_chrdev_region();
@elif defined(LDV_LINUX_USB_GADGET)
	return ldv_linux_usb_gadget_register_chrdev_region();
@endif /* LDV_LINUX_USB_GADGET */
}

after: execution(static inline int register_chrdev(unsigned int major, ..))
{
@if defined(LDV_LINUX_FS_CHAR_DEV) && defined(LDV_LINUX_USB_GADGET)
	int res1 = ldv_linux_fs_char_dev_register_chrdev(major);
	int res2 = ldv_linux_usb_gadget_register_chrdev(major);
	ldv_assume(res1 == res2);
	return res1;
@elif defined(LDV_LINUX_FS_CHAR_DEV)
	return ldv_linux_fs_char_dev_register_chrdev(major);
@elif defined(LDV_LINUX_USB_GADGET)
	return ldv_linux_usb_gadget_register_chrdev(major);
@endif /* LDV_LINUX_USB_GADGET */
}

after: call(void unregister_chrdev_region(..)) ||
       execution(static inline void unregister_chrdev(..))
{
@ifdef LDV_LINUX_FS_CHAR_DEV
	ldv_linux_fs_char_dev_unregister_chrdev_region();
@endif /* LDV_LINUX_FS_CHAR_DEV */

@ifdef LDV_LINUX_USB_GADGET
	ldv_linux_usb_gadget_unregister_chrdev_region();
@endif /* LDV_LINUX_USB_GADGET */
}

around: call(void *usb_alloc_coherent(.., gfp_t flags, ..))
{
@ifdef LDV_LINUX_USB_COHERENT
	void *res = ldv_linux_usb_coherent_usb_alloc_coherent();
	/* TODO: why this is modelled here? */
	ldv_assume(!ldv_is_err(res));
@endif /* LDV_LINUX_USB_COHERENT */

@ifdef LDV_LINUX_ALLOC_IRQ
	ldv_linux_alloc_irq_check_alloc_flags(flags);
@endif /* LDV_LINUX_ALLOC_IRQ */

@ifdef LDV_LINUX_ALLOC_USB_LOCK
	ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
@endif /* LDV_LINUX_ALLOC_USB_LOCK */

@ifdef LDV_LINUX_USB_COHERENT
	return res;
@endif /* LDV_LINUX_USB_COHERENT */
}

around: call(struct urb *usb_alloc_urb(.., gfp_t flags, ..))
{
@ifdef LDV_LINUX_USB_URB
	struct urb *res = ldv_linux_usb_urb_usb_alloc_urb();
	/* TODO: why this is modelled here? */
	ldv_assume(!ldv_is_err(res));
@endif /* LDV_LINUX_USB_URB */

@ifdef LDV_LINUX_ALLOC_IRQ
	ldv_linux_alloc_irq_check_alloc_flags(flags);
@endif /* LDV_LINUX_ALLOC_IRQ */

@ifdef LDV_LINUX_ALLOC_USB_LOCK
	ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
@endif /* LDV_LINUX_ALLOC_USB_LOCK */

@ifdef LDV_LINUX_USB_URB
	return res;
@endif /* LDV_LINUX_USB_URB */
}

around: call(void ldv_check_final_state(void))
{
@ifdef LDV_LINUX_ARCH_IO
	ldv_linux_arch_io_check_final_state();
@endif /* LDV_LINUX_ARCH_IO */

@ifdef LDV_LINUX_BLOCK_GENHD
	ldv_linux_block_genhd_check_final_state();
@endif /* LDV_LINUX_BLOCK_GENHD */

@ifdef LDV_LINUX_BLOCK_QUEUE
	ldv_linux_block_queue_check_final_state();
@endif /* LDV_LINUX_BLOCK_QUEUE */

@ifdef LDV_LINUX_BLOCK_REQUEST
	ldv_linux_block_request_check_final_state();
@endif /* LDV_LINUX_BLOCK_REQUEST */

@ifdef LDV_LINUX_DRIVERS_BASE_CLASS
	ldv_linux_drivers_base_class_check_final_state();
@endif /* LDV_LINUX_DRIVERS_BASE_CLASS */

@ifdef LDV_LINUX_DRIVERS_BASE_DMA_MAPPING
	ldv_linux_drivers_base_dma_mapping_check_final_state();
@endif /* LDV_LINUX_DRIVERS_BASE_DMA_MAPPING */

@ifdef LDV_LINUX_FS_CHAR_DEV
	ldv_linux_fs_char_dev_check_final_state();
@endif /* LDV_LINUX_FS_CHAR_DEV */

@ifdef LDV_LINUX_FS_SYSFS
	ldv_linux_fs_sysfs_check_final_state();
@endif /* LDV_LINUX_FS_SYSFS */

@ifdef LDV_LINUX_KERNEL_LOCKING_RWLOCK
	ldv_linux_kernel_locking_rwlock_check_final_state();
@endif /* LDV_LINUX_KERNEL_LOCKING_RWLOCK */

@ifdef LDV_LINUX_KERNEL_MODULE
	ldv_linux_kernel_module_check_final_state();
@endif /* LDV_LINUX_KERNEL_MODULE */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_BH
	ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_BH */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_SCHED
	ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK_SCHED */

@ifdef LDV_LINUX_KERNEL_RCU_UPDATE_LOCK
	ldv_linux_kernel_rcu_update_lock_check_final_state();
@endif /* LDV_LINUX_KERNEL_RCU_UPDATE_LOCK */

@ifdef LDV_LINUX_KERNEL_RCU_SRCU
	ldv_linux_kernel_rcu_srcu_check_final_state();
@endif /* LDV_LINUX_KERNEL_RCU_SRCU */

@ifdef LDV_LINUX_LIB_IDR
	ldv_linux_lib_idr_check_final_state();
@endif /* LDV_LINUX_LIB_IDR */

@ifdef LDV_LINUX_MMC_SDIO_FUNC
	ldv_linux_mmc_sdio_func_check_final_state();
@endif /* LDV_LINUX_MMC_SDIO_FUNC */

@ifdef LDV_LINUX_NET_RTNETLINK
	ldv_linux_net_rtnetlink_check_final_state();
@endif /* LDV_LINUX_NET_RTNETLINK */

@ifdef LDV_LINUX_NET_SOCK
	ldv_linux_net_sock_check_final_state();
@endif /* LDV_LINUX_NET_SOCK */

@ifdef LDV_LINUX_USB_COHERENT
	ldv_linux_usb_coherent_check_final_state();
@endif /* LDV_LINUX_USB_COHERENT */

@ifdef LDV_LINUX_USB_GADGET
	ldv_linux_usb_gadget_check_final_state();
@endif /* LDV_LINUX_USB_GADGET */

@ifdef LDV_LINUX_USB_URB
	ldv_linux_usb_urb_check_final_state();
@endif /* LDV_LINUX_USB_URB */
}
