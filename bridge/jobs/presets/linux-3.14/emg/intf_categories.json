{
  "kernel functions": {
    "usb_reset_device": {
      "signature": "int usb_reset_device(struct usb_device)",
      "header": "include/linux/usb.h"
    },
    "usb_register_driver": {
      "signature": "int usb_register_driver(*%usb.usb_driver%, $, $)",
      "header": "include/linux/usb.h"
    },
    "usb_deregister": {
      "signature": "$ usb_deregister(*%usb.usb_driver%)",
      "header": "include/linux/usb.h"
    },
    "platform_driver_unregister": {
      "signature": "$ platform_driver_unregister(*%platform.platform_driver%)",
      "header": "include/linux/platform_device.h"
    },
    "platform_driver_probe": {
      "signature": "$ platform_driver_probe(*%platform.platform_driver%, %platform.probe%)",
      "header": "include/linux/platform_device.h"
    },
    "platform_driver_register": {
      "signature": "$ platform_driver_register(*%platform.platform_driver%)",
      "header": "include/linux/platform_device.h"
    },
    "alloc_netdev": {
      "signature": "*%net.net_device% alloc_netdev($, $, $, %net.setup%)",
      "header": "include/linux/netdevice.h"
    },
    "register_netdev": {
      "signature": "$ register_netdev(*%net.net_device%)",
      "header": "include/linux/netdevice.h"
    },
    "unregister_netdev": {
      "signature": "$ unregister_netdev(*%net.net_device%)",
      "header": "include/linux/netdevice.h"
    },
    "free_netdev": {
      "signature": "$ free_netdev(*%net.net_device%)",
      "header": "include/linux/netdevice.h"
    },
    "mod_timer": {
      "signature": "$ mod_timer(*%timer.timer_list%, %timer.data%)",
      "header": "include/linux/timer.h"
    },
    "mod_timer_pinned": {
      "signature": "int mod_timer_pinned(*%timer.timer_list%, %timer.data%)",
      "header": "include/linux/timer.h"
    },
    "mod_timer_pending": {
      "signature": "int mod_timer_pending(*%timer.timer_list%, %timer.data%)",
      "header": "include/linux/timer.h"
    },
    "del_timer": {
      "signature": "int del_timer(*%timer.timer_list%)",
      "header": "include/linux/timer.h"
    },
    "del_timer_sync": {
      "signature": "int del_timer_sync(*%timer.timer_list%)",
      "header": "include/linux/timer.h"
    },
    "try_to_del_timer_sync": {
      "signature": "int try_to_del_timer_sync(*%timer.timer_list%)",
      "header": "include/linux/timer.h"
    },
    "request_threaded_irq": {
      "signature": "int request_threaded_irq(%interrupt.line%, %interrupt.handler%, %interrupt.thread%, $, $, %interrupt.data%)",
      "header": "include/linux/interrupt.h"
    },
    "request_irq": {
      "signature": "int request_irq(%interrupt.line%, %interrupt.handler%, $, $, %interrupt.data%)",
      "header": "include/linux/interrupt.h"
    },
    "devm_request_threaded_irq": {
      "signature": "int devm_request_threaded_irq($, %interrupt.line%, %interrupt.handler%, %interrupt.thread%, $, $, %interrupt.data%)",
      "header": "include/linux/interrupt.h"
    },
    "free_irq": {
      "signature": "$ free_irq(%interrupt.line%, %interrupt.data%)",
      "header": "include/linux/interrupt.h"
    },
    "i2c_register_driver": {
      "signature": "int i2c_register_driver($, *%i2c.i2c_driver%)",
      "header": "include/linux/i2c.h"
    },
    "i2c_del_driver": {
      "signature": "void i2c_del_driver(*%i2c.i2c_driver%)",
      "header": "include/linux/i2c.h"
    }
  },
  "kernel macro-functions": {},
  "categories": {
    "usb": {
      "extensible": false,
      "containers": {
        "usb_driver": {
          "header": "include/linux/usb.h",
          "signature": "struct usb_driver driver",
          "fields": {
            "pre_reset": "%usb.pre%",
            "post_reset": "%usb.post%",
            "disconnect": "%usb.release%",
            "suspend": "%usb.suspend%",
            "resume": "%usb.resume%"
          }
        }
      },
      "callbacks": {
        "pre": {
          "signature": "int (*pre) (%usb.usb_interface%)"
        },
        "post": {
          "signature": "int (*post) (%usb.usb_interface%)"
        },
        "release": {
          "signature": "void (*release) (%usb.usb_interface%)"
        },
        "suspend": {
          "signature": "int (*suspend) (%usb.usb_interface%, $)"
        },
        "resume": {
          "signature": "int (*resume) (%usb.usb_interface%)"
        }
      },
      "resources": {
        "usb_interface": {
          "signature": "struct usb_interface *usb_interface",
          "header": "include/linux/usb.h",
          "implemented in kernel": true
        }
      }
    },
    "net": {
      "containers": {
        "net_device": {
          "signature": "struct net_device net_device",
          "header": "include/linux/netdevice.h",
          "fields": {
            "netdev_ops": "*%net.net_device_ops%",
            "ethtool_ops": "*%net.ethtool_ops%"
          }
        },
        "net_device_ops": {
          "signature": "struct net_device_ops net_device_ops",
          "header": "include/linux/netdevice.h",
          "fields": {
            "ndo_open": "%net.open%",
            "ndo_stop": "%net.stop%"
          }
        },
        "ethtool_ops": {
          "signature": "struct ethtool_ops ethtool_ops",
          "header": "include/linux/netdevice.h"
        }
      },
      "callbacks": {
        "open": {
          "signature": "int (*open)(*%net.net_device%)"
        },
        "stop": {
          "signature": "int (*stop)(*%net.net_device%)"
        },
        "setup": {
          "signature": "$ (*setup)(*%net.net_device%)"
        }
      }
    },
    "proto": {
      "containers": {
        "proto_ops": {
          "signature": "struct proto_ops ops",
          "header": "include/linux/net.h",
          "fields": {
            "bind": "%proto.probe%",
            "release": "%proto.release%"
          }
        }
      },
      "resources": {
        "socket": {
          "signature": "struct socket *socket"
        }
      },
      "callbacks": {
        "probe": {
          "signature": "int (*probe)(%proto.socket%, $, $)"
        },
        "release": {
          "signature": "int (*release)(%proto.socket%)"
        }
      }
    },
    "device_driver": {
      "containers": {
        "device_driver": {
          "signature": "struct device_driver driver",
          "header": "include/linux/device.h",
          "fields": {
            "pm": "*%device_driver.dev_pm_ops%"
          }
        },
        "dev_pm_ops": {
          "signature": "struct dev_pm_ops ops",
          "header": "include/linux/pm.h"
        }
      }
    },
    "platform": {
      "containers": {
        "platform_driver": {
          "signature": "struct platform_driver driver",
          "header": "include/linux/platform_device.h",
          "fields": {
            "probe": "%platform.probe%",
            "remove": "%platform.release%"
          }
        }
      },
      "resources": {
        "platform_device": {
          "signature": "struct platform_device *device",
          "header": "include/linux/platform_device.h",
          "implemented in kernel": true
        }
      },
      "callbacks": {
        "probe": {
          "signature": "int (*probe)(%platform.platform_device%)"
        },
        "release": {
          "signature": "int (*release)(%platform.platform_device%)"
        }
      }
    },
    "file_operations": {
      "containers": {
        "file_operations": {
          "signature": "struct file_operations ops",
          "header": "include/linux/fs.h",
          "fields": {
            "release": "%file_operations.release%",
            "open": "%file_operations.probe%"
          }
        }
      },
      "resources": {
        "file": {
          "signature": "struct file *file"
        },
        "inode": {
          "signature": "struct inode *inode"
        }
      },
      "callbacks": {
        "probe": {
          "signature": "int (*probe) (%file_operations.inode%, %file_operations.file%)"
        },
        "release": {
          "signature": "$ (*release) (%file_operations.inode%, %file_operations.file%)"
        }
      }
    },
    "i2c": {
      "containers": {
        "i2c_driver": {
          "signature": "struct i2c_driver driver",
          "header": "include/linux/i2c.h",
          "fields": {
            "remove": "%i2c.release%"
          }
        }
      },
      "resources": {
        "client": {
          "signature": "struct i2c_client *client"
        }
      },
      "callbacks": {
        "release": {
          "signature": "int (*release)(%i2c.client%)"
        }
      }
    },
    "Qdisc": {
      "containers": {
        "Qdisc_ops": {
          "signature": "struct Qdisc_ops ops",
          "header": "include/net/sch_generic.h",
          "fields": {
            "init": "%Qdisc.probe%",
            "destroy": "%Qdisc.release%"
          }
        }
      },
      "resources": {
        "Qdisc": {
          "signature": "struct Qdisc *disc"
        }
      },
      "callbacks": {
        "probe": {
          "signature": "int (*probe)(%Qdisc.Qdisc%, $)"
        },
        "release": {
          "signature": "void (*release)(%Qdisc.Qdisc%)"
        }
      }
    },
    "timer": {
      "extensible": false,
      "containers": {
        "timer_list": {
          "signature": "struct timer_list list",
          "header": "include/linux/timer.h",
          "fields": {
            "data": "%timer.data%",
            "function": "%timer.handler%"
          }
        }
      },
      "resources": {
        "data": {
          "signature": "unsigned long data"
        }
      },
      "callbacks": {
        "handler": {
          "signature": "void (*handler)(%timer.data%)",
          "interrupt context": true
        }
      }
    },
    "interrupt": {
      "extensible": false,
      "containers": {},
      "resources": {
        "line": {
          "signature": "int line"
        },
        "data": {
          "signature": "void *data"
        }
      },
      "callbacks": {
        "handler": {
          "signature": "irqreturn_t (*handler)(%interrupt.line%, %interrupt.data%)",
          "interrupt context": true
        },
        "thread": {
          "signature": "irqreturn_t (*thread)(%interrupt.line%, %interrupt.data%)"
        }
      }
    }
  }
}
